<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:sch="http://purl.oclc.org/dsdl/schematron" elementFormDefault="qualified" targetNamespace="http://www.loc.gov/mods/v3" xmlns:mods="http://www.loc.gov/mods/v3" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:cdl="http://www.cdlib.org/inside/diglib/copyrightMD">
  <xs:import namespace="http://www.w3.org/1999/xlink" schemaLocation="https://www.w3.org/XML/2008/06/xlink.xsd"/>
  <xs:import namespace="http://www.cdlib.org/inside/diglib/copyrightMD" schemaLocation="copyrightMD_schema.xsd" />
    <!-- to do: fix Schematron rule to validate URL formatting -->
    <!-- backwards compatible, should replace old schema -->
  <xs:annotation>
    <xs:appinfo>
      <sch:title>MSUL MODS 3.7 Schema/Schematron Validation</sch:title>
      <sch:ns prefix="mods" uri="http://www.loc.gov/mods/v3"/>
    </xs:appinfo>
  </xs:annotation> 
  <xs:element name="mods">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:mods">          
            <sch:assert test="count(mods:name[@usage='primary'])=1 or count(mods:name[@usage='primary'])=0">Record may only contain a maximum of one mods:name with @usage='primary'.</sch:assert>
            <sch:assert test="mods:subject[@authority='fast']">Record must have at least one FAST subject.</sch:assert>
            <sch:assert test="mods:originInfo/mods:dateOther[@type='year']">Record must have a mods:dateOther[@type='year'] element.</sch:assert>
            <sch:assert test="mods:genre[@authority='dct']">Record must have a DCTerms genre.</sch:assert>
            <sch:assert test="mods:genre[@authority='aat']">Record must have an AAT genre.</sch:assert>            
            <sch:assert test="mods:relatedItem[@type='host']">Record must contain a mods:relatedItem element for the collection name with type attribute of 'host'.</sch:assert>
            <sch:assert test="mods:identifier[@type='filename']">Record must contain a mods:identifier element with type attribute of 'filename'.</sch:assert>
            <sch:assert test="count(mods:classification[not(@type)])&lt;=1">Record may not contain more than one mods:classification[not(@type)]</sch:assert>
            <sch:assert test="count(mods:classification[@type='lcc'])&lt;=1">Record may not contain more than one mods:classification[@type='lcc']</sch:assert>
            <sch:assert test="mods:accessCondition[@type='use and reproduction'] or mods:accessCondition[@type='rights holder']">Record must have either a mods:accessCondition element with type attribute of 'use and reproduction' (for non-TIC resources) or with type attribute 'rights holder' (TIC resources).</sch:assert>
            <sch:assert test="mods:recordInfo/mods:recordContentSource">Record must have a mods:recordContentSource element.</sch:assert>
            <sch:assert test="mods:recordInfo/mods:recordCreationDate">Record must have a mods:recordCreationDate element.</sch:assert>
            <sch:assert test="mods:recordInfo/mods:languageOfCataloging">Record must have a mods:languageOfCataloging element.</sch:assert>
            <!-- count for certain elements -->
            <sch:assert test="count(mods:originInfo)=1">mods:originInfo must appear once and only once.</sch:assert>
            <sch:assert test="count(mods:physicalDescription)=1">mods:physicalDescription must appear once and only once.</sch:assert>
            <sch:assert test="count(mods:abstract)&lt;=1">mods:abstract may only appear once.</sch:assert>
            <sch:assert test="count(mods:recordInfo)=1">mods:recordInfo must appear once and only once.</sch:assert>
            <sch:assert test="count(mods:accessCondition[@type='dpla'])=1">mods:accessCondition[@type='dpla'] must appear once and only once.</sch:assert>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType>
      <xs:choice maxOccurs="unbounded">
        <xs:element ref="mods:titleInfo"/>
        <xs:element ref="mods:name"/>
        <xs:element ref="mods:typeOfResource"/>
        <xs:element ref="mods:genre" minOccurs="2" maxOccurs="unbounded"/>
        <xs:element ref="mods:originInfo"/>
        <xs:element ref="mods:language"/>
        <xs:element ref="mods:physicalDescription"/>
        <xs:element ref="mods:tableOfContents"/>
        <xs:element ref="mods:abstract"/>
        <xs:element ref="mods:note"/>
        <xs:element ref="mods:subject"/>
        <xs:element ref="mods:classification"/>
        <xs:element ref="mods:location"/>
        <xs:element ref="mods:relatedItem"/>
        <xs:element ref="mods:identifier"/>
        <xs:element ref="mods:accessCondition"/>
        <xs:element ref="mods:recordInfo"/>
      </xs:choice>
      <xs:attribute name="version" type="xs:decimal"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="name">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule abstract="true" id="naf-uri">
            <sch:assert test="contains(.,'id.loc.gov/authorities/names')">mods:name[@valueURI] must be from NAF vocabulary.</sch:assert>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType>
      <xs:choice maxOccurs="unbounded">
        <xs:element ref="mods:namePart" maxOccurs="unbounded"/>
        <xs:element ref="mods:titleInfo" minOccurs="0" maxOccurs="1"/>
        <xs:element ref="mods:nameIdentifier" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:role" maxOccurs="unbounded"/>        
      </xs:choice>      
      <xs:attribute name="type" use="required" type="xs:string"/>
      <xs:attribute name="usage">
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:enumeration value="primary"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
      <xs:attribute name="authorityURI" use="optional" type="xs:anyURI"/>
      <xs:attribute name="valueURI" use="optional" type="xs:anyURI">
        <xs:annotation>
          <xs:appinfo>
            <sch:pattern>
              <sch:rule context="mods:name/@valueURI">
                <sch:extends rule="naf-uri"/>
              </sch:rule>
            </sch:pattern>
          </xs:appinfo>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="authority" use="optional">
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:enumeration value="naf"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
    </xs:complexType>
  </xs:element>
  <xs:element name="namePart">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule abstract="true" id="trailing-punct">
            <sch:assert role="warning" test="not(ends-with(.,'.')) and not(ends-with(.,',')) and not(ends-with(.,':')) and not(ends-with(.,' ')) and not(ends-with(.,'/')) or matches(.,' ([A-Z]\.){0,2}[A-Z]{1}\.$') or matches(.,' (Co|Inc)\.$') or matches(.,' ?(Mr|Mrs|Ms|Sr|Jr)\.$')">Check <sch:name/> for trailing punctuation.</sch:assert>
          </sch:rule>
        </sch:pattern>
        <sch:pattern>
          <sch:rule abstract="true" id="blank-element">
            <sch:assert test="string-length(.) &gt; 0"><sch:name/> is blank.</sch:assert>
          </sch:rule>
        </sch:pattern>
        <sch:pattern>
          <sch:rule context="mods:namePart">
            <sch:extends rule="trailing-punct"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern>
          <sch:rule context="mods:namePart">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType mixed="true">
      <xs:attribute name="type" use="optional" type="xs:string"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="role">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="mods:roleTerm" maxOccurs="2"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="nameIdentifier">
      <xs:annotation>
          <xs:appinfo>
              <sch:pattern>
                  <sch:rule abstract="true" id="url-format">
                      <!-- regex doesn't flag double punctuation when it should -->
                      <sch:assert role="warning" test="matches(.,'^https?://[a-zA-Z0-9]+\.[a-zA-Z0-9\p{P}]+((\.|/){1}[a-zA-Z0-9\p{P}])*$') and not(contains(.,' ')) and not(contains(.,'\')) and not(ends-with(.,'.'))">URL in <sch:name/> may be formatted incorrectly.</sch:assert>
                  </sch:rule>
              </sch:pattern>
              <sch:pattern>
                  <sch:rule context="mods:nameIdentifier">
                      <sch:extends rule="url-format"/>
                  </sch:rule>
              </sch:pattern>
              <sch:pattern>
                <sch:rule context="mods:nameIdentifier">
                  <sch:report test="../../../mods:mods[@version='3.5']">mods:nameIdentifier is not a legal element in MODS 3.5. Use MODS version 3.6 or later.</sch:report>
                </sch:rule>
              </sch:pattern>
          </xs:appinfo>
      </xs:annotation>
      <xs:complexType mixed="true">            
          <xs:simpleContent>
              <xs:extension base="xs:anyURI">
                  <xs:attribute name="type" use="required">
                    <xs:simpleType>
                      <xs:restriction base="xs:string">
                        <xs:enumeration value="isni"/>
                        <xs:enumeration value="orcid"/>
                      </xs:restriction>
                    </xs:simpleType>
                  </xs:attribute>
              </xs:extension>
          </xs:simpleContent>
      </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="authority-attributes-required">
    <xs:attribute name="authority" use="required" type="xs:string"/>
    <xs:attribute name="authorityURI" use="required" type="xs:anyURI">
        <!-- this rule will check @authorityURI anywhere in the target record regardless of attributeGroup -->
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:rule context="@authorityURI">
                        <sch:extends rule="url-format"/>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
    </xs:attribute>
    <xs:attribute name="valueURI" use="required" type="xs:anyURI">
        <!-- this rule will check @valueURI anywhere in the target record regardless of attributeGroup -->
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:rule context="@valueURI">
                        <sch:extends rule="url-format"/>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
    </xs:attribute>    
  </xs:attributeGroup>
  <xs:attributeGroup name="authority-attributes-optional">
    <xs:attribute name="authority" use="optional" type="xs:string"/>
    <xs:attribute name="authorityURI" use="optional" type="xs:anyURI"/>        
    <xs:attribute name="valueURI" use="optional" type="xs:anyURI"/>        
  </xs:attributeGroup>
  <xs:element name="roleTerm">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:roleTerm">
            <sch:extends rule="trailing-punct"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern>
          <sch:rule context="mods:roleTerm">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType mixed="true">
      <xs:attribute name="type" use="required" type="xs:string"/>
      <xs:attributeGroup ref="mods:authority-attributes-required"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="typeOfResource" type="xs:string">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:typeOfResource">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <!-- don't add authority info to typeOfResource for now, may revisit later -->
    <!--<xs:complexType mixed="true">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attributeGroup ref="mods:authority-attributes-optional"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>-->
  </xs:element>
  <xs:element name="genre">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:genre">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType mixed="true">
      <xs:attributeGroup ref="mods:authority-attributes-required"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="originInfo">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule abstract="true" id="edtf-formatting">
            <!-- pre-2019 version of EDTF <sch:assert test="matches(.,'^([\dx]{4}|[\dx]{4}-[\dx]{2}|[\dx]{4}-[\dx]{2}-[\dx]{2}|unknown)[~?]?[/]?([\dx]{4}|[\dx]{4}-[\dx]{2}|[\dx]{4}-[\dx]{2}-[\dx]{2}|unknown|open)?[~?]?$')">Date in <sch:name/> is formatted incorrectly.</sch:assert> -->
            <sch:assert test="matches(.,'^[\dx]{4}$|^[/]{1}[\dx]{4}$|^[\dx]{4}[/]{1}$|^[\dx]{4}-[\dx]{2}$|^([\dx]{4}(-[\dx]{2})?(-[\dx]{2})?[~?]?[/]?[\dx]{4}(-[\dx]{2})?(-[\dx]{2})?[~?]?)$')">Date in <sch:name/> is formatted incorrectly.</sch:assert>
          </sch:rule>
          <sch:rule abstract="true" id="date-value">
            <sch:assert test="(matches(.,'^[\dx]{4}$')) or (matches(.,'^[\dx]{4}-[\dx]{2}$') and number(substring(.,6,2))&lt;=12 and number(substring(.,6,2))&gt;=1) or (matches(.,'^[\dx]{4}-[\dx]{2}-[\dx]{2}$') and number(substring(.,6,2))&lt;=12 and number(substring(.,6,2))&gt;=1 and number(substring(.,9,2))&lt;=31 and number(substring(.,9,2))&gt;=1) or (contains(.,'/')) or (contains(.,'unknown') or (contains(.,'?')))">Month or day in <sch:name/> is incorrect.</sch:assert>
          </sch:rule>
        </sch:pattern>
        <sch:pattern>
          <sch:rule context="mods:originInfo/mods:dateIssued">
            <sch:extends rule="edtf-formatting"/>
          </sch:rule>
          <sch:rule context="mods:originInfo/mods:dateCreated">
            <sch:extends rule="edtf-formatting"/>
          </sch:rule>          
        </sch:pattern>
        <sch:pattern>
          <sch:rule context="mods:originInfo/mods:dateIssued">
            <sch:extends rule="date-value"/>
          </sch:rule>
          <sch:rule context="mods:originInfo/mods:dateCreated">
            <sch:extends rule="date-value"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType mixed="false">      
      <xs:choice maxOccurs="unbounded">
        <xs:element ref="mods:place"/>
        <xs:element ref="mods:publisher" minOccurs="0"/>
        <xs:element ref="mods:dateIssued"/>
        <xs:element ref="mods:dateCreated"/>
        <xs:element ref="mods:dateOther"/>
        <xs:element ref="mods:copyrightDate" minOccurs="0"/>
        <xs:element ref="mods:issuance" minOccurs="0"/>
        <xs:element ref="mods:frequency" minOccurs="0"/>
        <xs:element ref="mods:edition" minOccurs="0"/>
      </xs:choice>
      <xs:attribute name="eventType" use="optional"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="place">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="mods:placeTerm" maxOccurs="unbounded"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="placeTerm">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:placeTerm">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType mixed="true">
      <xs:attribute name="type" use="required" type="xs:string"/>
      <xs:attributeGroup ref="mods:authority-attributes-optional"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="publisher">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:publisher">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType mixed="true">
      <xs:simpleContent>
        <xs:extension base="xs:string">
          <xs:attributeGroup ref="mods:authority-attributes-optional">
            <xs:annotation>
              <xs:appinfo>
                <sch:pattern>
                  <sch:rule context="mods:publisher[@authority]">
                    <sch:assert test="../../../mods:mods[@version='3.7' or not(@version)]">@authority is only valid for use on mods:publisher in MODS version 3.7.</sch:assert>
                  </sch:rule>
                </sch:pattern>
                <sch:pattern>
                  <sch:rule context="mods:publisher[@authorityURI]">
                    <sch:assert test="../../../mods:mods[@version='3.7' or not(@version)]">@authorityURI is only valid for use on mods:publisher in MODS version 3.7.</sch:assert>
                  </sch:rule>
                </sch:pattern>
                <sch:pattern>
                  <sch:rule context="mods:publisher[@valueURI]">
                    <sch:assert test="../../../mods:mods[@version='3.7' or not(@version)]">@valueURI is only valid for use on mods:publisher in MODS version 3.7.</sch:assert>
                  </sch:rule>
                </sch:pattern>
              </xs:appinfo>
            </xs:annotation>
          </xs:attributeGroup>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="dateIssued">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:dateIssued">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base="xs:string">
          <xs:attribute name="encoding" use="required">
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="edtf"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="keyDate" use="required">
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="yes"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
          <!-- comment out optional calendar element for now, haven't had a use case for this yet -->
          <!--<xs:attribute name="calendar" use="optional"/>-->
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="dateCreated">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:dateCreated">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base="xs:string">
          <xs:attribute name="encoding" use="required">
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="edtf"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="keyDate" use="required">
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="yes"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
          <!--<xs:attribute name="calendar" use="optional"/>-->
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="copyrightDate">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:copyrightDate">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base="xs:string">
          <xs:attribute name="encoding" use="required">
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="edtf"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
          <!--<xs:attribute name="calendar" use="optional"/>-->
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="dateOther">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:dateOther[@type='year']">
            <sch:assert test="matches(.,'^\d{4}$') or matches(.,'^\d{3}x$') or matches(.,'^\d{2}xx$') or matches(.,'^\dxxx$') or matches(.,'^\d{3}X$') or matches(.,'^\d{2}XX$') or matches(.,'^\dXXX$')">mods:dateOther[@type='year'] formatted incorrectly.</sch:assert>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base="xs:string">
          <xs:attribute name="encoding" use="required" type="xs:string"/>
          <xs:attribute name="type" use="required" type="xs:string"/>
          <!--<xs:attribute name="calendar" use="optional"/>-->
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="issuance" type="xs:string">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:issuance">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
  </xs:element>
  <xs:element name="frequency">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:frequency">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType mixed="true">
      <xs:attributeGroup ref="mods:authority-attributes-optional"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="edition">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:edition">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType mixed="true">
      <xs:attribute name="supplied" use="optional"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="language">
    <xs:complexType>      
      <xs:sequence>
        <xs:element ref="mods:languageTerm" maxOccurs="unbounded"/>
      </xs:sequence>
      <xs:attribute name="objectPart" use="optional" type="xs:string"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="physicalDescription">
    <xs:complexType>
      <xs:choice maxOccurs="unbounded">
        <xs:element ref="mods:form" minOccurs="0"/>
        <xs:element ref="mods:internetMediaType" minOccurs="0"/>
        <xs:element ref="mods:extent" minOccurs="0"/>
        <xs:element ref="mods:digitalOrigin" minOccurs="0"/>
        <xs:element ref="mods:note" minOccurs="0"/>
      </xs:choice>
    </xs:complexType>
  </xs:element>
  <xs:element name="tableOfContents" type="xs:string">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:tableOfContents">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
  </xs:element>
  <xs:element name="form">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:form">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType mixed="true">
      <xs:attributeGroup ref="mods:authority-attributes-optional"/>
      <xs:attribute name="type" use="optional" type="xs:string"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="internetMediaType" type="xs:string">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:internetMediaType">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
  </xs:element>
  <xs:element name="extent" type="xs:string">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:physicalDescription">
            <sch:assert test="mods:extent" role="warning">Use of mods:physicalDescription/mods:extent is recommended.</sch:assert>
          </sch:rule>
        </sch:pattern>
        <sch:pattern>
          <sch:rule context="mods:extent">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
  </xs:element>
  <xs:element name="digitalOrigin" type="xs:string">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:digitalOrigin">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
  </xs:element>
  <xs:element name="abstract" type="xs:string">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:abstract">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
  </xs:element>  
  <xs:element name="note">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:note">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType mixed="true">
      <xs:attribute name="type" use="optional"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="subject">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:subject[@authority='lcsh' or @authority='fast']">
            <sch:assert test="@authorityURI">FAST and LCSH subjects must have an authorityURI attribute.</sch:assert>
          </sch:rule>
        </sch:pattern>
        <sch:pattern>
          <sch:rule context="mods:subject[@authority='fast'][not(mods:temporal)]">
            <sch:assert test="@valueURI">FAST subjects must have a valueURI attribute.</sch:assert>
          </sch:rule>
        </sch:pattern>
        <sch:pattern>
          <sch:rule context="mods:subject[@authority='fast'][not(mods:temporal)]">
            <sch:assert test="matches(@valueURI,'http://id.worldcat.org/fast/[0-9]{1,}$')">mods:subject[@authority='fast'] valueURI attribute formatted incorrectly.</sch:assert>
          </sch:rule>
          <sch:rule context="mods:subject[@authority='lcsh' and @valueURI][not(mods:temporal)]">
            <sch:assert test="matches(@valueURI,'http://id.loc.gov/authorities/subjects/sh[0-9]{7,}$') or matches(@valueURI,'http://id.loc.gov/authorities/names/n[a-z]?[0-9]{7,}$')">mods:subject[@authority='lcsh'] valueURI attribute formatted incorrectly.</sch:assert>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType>
      <xs:choice maxOccurs="unbounded">
        <xs:element ref="mods:topic" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:geographic" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:temporal" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:hierarchicalGeographic" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:titleInfo" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:geographicCode" minOccurs="0" maxOccurs="1"/>
        <xs:element ref="mods:cartographics" minOccurs="0" maxOccurs="1"/>
        <xs:element name="genre" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element name="name" minOccurs="0" maxOccurs="unbounded">
          <xs:complexType>
            <xs:choice maxOccurs="unbounded">
              <xs:element ref="mods:namePart" maxOccurs="unbounded"/>
              <xs:element ref="mods:nameIdentifier" minOccurs="0" maxOccurs="unbounded"/>
            </xs:choice>
            <xs:attribute name="type" use="required" type="xs:string"/>
          </xs:complexType>
        </xs:element>
      </xs:choice>
      <xs:attribute name="authority" type="xs:string">
        <xs:annotation>
          <xs:appinfo>
            <sch:pattern>
              <sch:rule context="mods:subject[not(mods:cartographics)]">
                <sch:assert test="@authority" role="warn">Use of @authority attribute on mods:subject is highly recommended.</sch:assert>
              </sch:rule>
            </sch:pattern>
          </xs:appinfo>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="authorityURI" type="xs:anyURI"/>
      <xs:attribute name="valueURI" type="xs:anyURI"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="topic" type="xs:string">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:topic">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
  </xs:element>
  <xs:element name="geographic" type="xs:string">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:geographic">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
  </xs:element>
  <xs:element name="temporal" type="xs:string">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:temporal">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
  </xs:element>
  <xs:element name="geographicCode" type="xs:string">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:geographicCode">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
  </xs:element>
  <xs:element name="cartographics">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="mods:coordinates" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:scale" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:projection" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="coordinates" type="xs:string">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:coordinates">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
  </xs:element>
  <xs:element name="scale" type="xs:string">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:scale">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
  </xs:element>
  <xs:element name="projection" type="xs:string">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:projection">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
  </xs:element>
  <xs:attributeGroup name="hierarchicalGeographic_attributes_optional">
      <xs:attribute name="level" use="optional" type="xs:string">
          <xs:annotation>
            <xs:appinfo>
              <sch:pattern>
                <sch:rule context="mods:hierarchicalGeographic/*[@level]">
                  <sch:report test="../../../../mods:mods[@version='3.5']">@level is not a legal attribute in MODS 3.5. Use MODS version 3.6 or later.</sch:report>
                </sch:rule>
              </sch:pattern>
            </xs:appinfo>
          </xs:annotation>        
      </xs:attribute>
      <xs:attribute name="period" use="optional" type="xs:anyURI">
        <xs:annotation>
          <xs:appinfo>
            <sch:pattern>
              <sch:rule context="mods:hierarchicalGeographic/*[@period]">
                <sch:report test="../../../../mods:mods[@version='3.5']">@period is not a legal attribute in MODS 3.5. Use MODS version 3.6 or later.</sch:report>
              </sch:rule>
            </sch:pattern>
          </xs:appinfo>
        </xs:annotation>
      </xs:attribute>
  </xs:attributeGroup>
  <xs:element name="hierarchicalGeographic">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="mods:continent" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:country" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:region" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:state" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:territory" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:county" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:city" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:citySection" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:island" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:area" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:extraterrestrialArea" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="continent">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:continent">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType mixed="true">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attributeGroup ref="mods:hierarchicalGeographic_attributes_optional"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="country">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:country">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType mixed="true">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attributeGroup ref="mods:hierarchicalGeographic_attributes_optional"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="region">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:region">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType mixed="true">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute name="regionType" use="optional">
                  <xs:annotation>
                    <xs:appinfo>
                      <sch:pattern>
                        <sch:rule context="mods:region[@regionType]">
                          <sch:report test="../../../../mods:mods[@version='3.5']">@regionType is not a legal attribute in MODS 3.5. Use MODS version 3.6 or later.</sch:report>
                        </sch:rule>
                      </sch:pattern>
                    </xs:appinfo>
                  </xs:annotation>
                </xs:attribute>
                <xs:attributeGroup ref="mods:hierarchicalGeographic_attributes_optional"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="state">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:state">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType mixed="true">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attributeGroup ref="mods:hierarchicalGeographic_attributes_optional"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="territory">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:territory">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType mixed="true">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attributeGroup ref="mods:hierarchicalGeographic_attributes_optional"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="county">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:county">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType mixed="true">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attributeGroup ref="mods:hierarchicalGeographic_attributes_optional"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="city">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:city">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType mixed="true">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attributeGroup ref="mods:hierarchicalGeographic_attributes_optional"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="citySection">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:citySection">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType mixed="true">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute name="citySectionType" use="optional">
                  <xs:annotation>
                    <xs:appinfo>
                      <sch:pattern>
                        <sch:rule context="mods:citySection[@citySectionType]">
                          <sch:report test="../../../../mods:mods[@version='3.5']">@citySectionType is not a legal attribute in MODS 3.5. Use MODS version 3.6 or later.</sch:report>
                        </sch:rule>
                      </sch:pattern>
                    </xs:appinfo>
                  </xs:annotation>
                </xs:attribute>
                <xs:attributeGroup ref="mods:hierarchicalGeographic_attributes_optional"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="island">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:island">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType mixed="true">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attributeGroup ref="mods:hierarchicalGeographic_attributes_optional"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="area">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:area">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType mixed="true">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute name="areaType" use="optional">
                  <xs:annotation>
                    <xs:appinfo>
                      <sch:pattern>
                        <sch:rule context="mods:area[@areaType]">
                          <sch:report test="../../../../mods:mods[@version='3.5']">@areaType is not a legal attribute in MODS 3.5. Use MODS version 3.6 or later.</sch:report>
                        </sch:rule>
                      </sch:pattern>
                    </xs:appinfo>
                  </xs:annotation>
                </xs:attribute>
                <xs:attributeGroup ref="mods:hierarchicalGeographic_attributes_optional"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="extraterrestrialArea">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:extraterrestrialArea">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType mixed="true">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attributeGroup ref="mods:hierarchicalGeographic_attributes_optional"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="classification">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:classification">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType mixed="true">
      <xs:attributeGroup ref="mods:authority-attributes-optional"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="location">
    <xs:complexType>
      <xs:choice maxOccurs="unbounded">
        <xs:element ref="mods:physicalLocation"/>
        <xs:element ref="mods:url"/>
      </xs:choice>
    </xs:complexType>
  </xs:element>
  <xs:element name="url">
    <xs:complexType mixed="true">
      <xs:annotation>
        <xs:appinfo>
          <sch:pattern>
            <sch:rule context="mods:location/mods:url">
              <sch:assert test="@access or @usage or @note">mods:location/mods:url requires either a @usage, @access, or @note attribute.</sch:assert>
            </sch:rule>
          </sch:pattern>
        </xs:appinfo>
      </xs:annotation>
      <xs:simpleContent>
        <xs:extension base="xs:anyURI">
          <xs:attribute name="usage" use="optional">
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="primary"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="access" use="optional">
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="preview"/>
                <xs:enumeration value="object in context"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="note" use="optional"/>
        </xs:extension>
      </xs:simpleContent>     
    </xs:complexType>
  </xs:element>
  <xs:element name="physicalLocation">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:physicalLocation">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType mixed="true">
      <xs:attributeGroup ref="mods:authority-attributes-optional"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="relatedItem">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:relatedItem[@type='host']">
            <sch:assert test="mods:identifier[@type='oai_set']">mods:relatedItem[@type='host'] must have an oai_set identifier.</sch:assert>
          </sch:rule>
        </sch:pattern>
        <sch:pattern>
          <sch:rule context="mods:relatedItem">
            <sch:assert test=".[@type or @otherType]">mods:relatedItem must include either a @type or @otherType attribute.</sch:assert>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType>
      <xs:choice maxOccurs="unbounded">
        <xs:element name="name" minOccurs="0">
          <xs:annotation>
            <xs:appinfo>
              <sch:pattern>
                <sch:rule context="mods:name/mods:namePart">
                  <sch:extends rule="trailing-punct"/>
                </sch:rule>
              </sch:pattern>
            </xs:appinfo>
          </xs:annotation>
          <xs:complexType>
            <xs:choice maxOccurs="unbounded">
              <xs:element ref="mods:namePart" maxOccurs="unbounded"/>
              <xs:element ref="mods:nameIdentifier" minOccurs="0" maxOccurs="unbounded"/>        
            </xs:choice>      
            <xs:attribute name="type" use="required" type="xs:string"/>
            <xs:attributeGroup ref="mods:authority-attributes-optional"/>
          </xs:complexType>
        </xs:element>
        <xs:element ref="mods:titleInfo" minOccurs="0"/>
        <xs:element ref="mods:note" minOccurs="0"/>
        <xs:element ref="mods:location" minOccurs="0"/>
        <xs:element ref="mods:part" minOccurs="0"/>
        <xs:element ref="mods:identifier" minOccurs="0" maxOccurs="unbounded"/>
      </xs:choice>
      <xs:attribute name="type" use="optional" type="xs:string"/>
      <xs:attribute name="otherType" use="optional" type="xs:string">
        <xs:annotation>
          <xs:appinfo>
            <sch:pattern>
              <sch:rule context="mods:relatedItem[@otherType]">
                <sch:report test="../../mods:mods[@version='3.4']">@otherType is not a legal attribute in MODS 3.4. Use MODS version 3.6 or later.</sch:report>
                <sch:report test="../../mods:mods[@version='3.5']">@otherType is not a legal attribute in MODS 3.5. Use MODS version 3.6 or later.</sch:report>
              </sch:rule>
            </sch:pattern>
          </xs:appinfo>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="otherTypeAuth" use="optional" type="xs:string"/>
      <xs:attribute name="otherTypeAuthURI" use="optional" type="xs:anyURI"/>
      <xs:attribute name="otherTypeURI" use="optional" type="xs:anyURI"/>
      <xs:attribute ref="xlink:href" use="optional"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="part">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:part">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType>
      <xs:choice maxOccurs="unbounded">
        <xs:element ref="mods:detail" minOccurs="0"/>
      </xs:choice>
      <xs:attribute name="type" type="xs:string"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="detail">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:detail">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType>
      <xs:choice maxOccurs="unbounded">
        <xs:element ref="mods:number" minOccurs="0"/>
        <xs:element ref="mods:caption" minOccurs="0"/>
        <xs:element ref="mods:title" minOccurs="0"/>
      </xs:choice>
      <xs:attribute name="type" type="xs:string"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="number" type="xs:string">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:number">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
  </xs:element>  
  <xs:element name="caption" type="xs:string">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:caption">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
  </xs:element>   
  <xs:element name="accessCondition">
    <xs:complexType mixed="true">
      <xs:sequence minOccurs="0">
        <xs:element ref="cdl:copyright" minOccurs="0"/>
        <!-- CDL's schema (imported) validates the cdl:copyright element -->
      </xs:sequence>
      <xs:attribute name="type" use="required"/>
      <xs:attribute ref="xlink:href" use="optional"/>
      <!-- xlink schema (imported) validates the xlink:href element -->
    </xs:complexType>
  </xs:element>  
  <xs:element name="recordInfo">
    <xs:complexType>
      <xs:choice maxOccurs="unbounded">
        <xs:element ref="mods:descriptionStandard" minOccurs="0"/>
        <xs:element ref="mods:recordContentSource" minOccurs="1" maxOccurs="2"/>
        <xs:element ref="mods:recordCreationDate" maxOccurs="1"/>
        <xs:element ref="mods:recordChangeDate" maxOccurs="1"/>
        <xs:element ref="mods:recordIdentifier" minOccurs="0" maxOccurs="1"/>
        <xs:element ref="mods:recordOrigin" maxOccurs="1"/>
        <xs:element ref="mods:languageOfCataloging" minOccurs="1"/>
      </xs:choice>
    </xs:complexType>
  </xs:element>
  <xs:element name="descriptionStandard">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:descriptionStandard">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType mixed="true">
      <xs:attributeGroup ref="mods:authority-attributes-optional"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="recordContentSource">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:recordContentSource">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType mixed="true">
      <xs:attributeGroup ref="mods:authority-attributes-required"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="recordCreationDate">
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base="xs:date">
          <xs:attribute name="encoding" use="required" type="xs:string"/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="recordChangeDate">
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base="xs:date">
          <xs:attribute name="encoding" use="required" type="xs:string"/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="recordIdentifier">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:recordIdentifier">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType mixed="true">
      <xs:attribute name="source" type="xs:string"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="recordOrigin" type="xs:string">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:recordOrigin">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
  </xs:element>
  <xs:element name="languageOfCataloging">    
    <xs:complexType>
      <xs:sequence>
          <xs:element name="languageTerm" minOccurs="1">
              <xs:complexType mixed="true">
                  <xs:simpleContent>
                      <xs:extension base="xs:string">
                          <xs:attribute name="type" use="required">
                              <xs:simpleType>
                                  <xs:restriction base="xs:string">
                                      <xs:enumeration value="code"/>
                                      <xs:enumeration value="text"/>
                                  </xs:restriction>
                              </xs:simpleType>
                          </xs:attribute>
                          <xs:attribute name="authority" type="xs:string" use="required"/>
                          <xs:attribute name="authorityURI" type="xs:anyURI" use="optional"/>                             
                          <xs:attribute name="valueURI" type="xs:anyURI" use="optional"/>
                      </xs:extension>
                  </xs:simpleContent>
              </xs:complexType>
          </xs:element>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="titleInfo">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:titleInfo/mods:title">
            <sch:extends rule="trailing-punct"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern>
          <sch:rule context="mods:titleInfo/mods:subTitle">
            <sch:extends rule="trailing-punct"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType>
      <xs:choice maxOccurs="unbounded">
        <xs:element ref="mods:title" minOccurs="1" maxOccurs="1"/>
        <xs:element ref="mods:subTitle" minOccurs="0" maxOccurs="1"/>
        <xs:element ref="mods:partName" minOccurs="0" maxOccurs="1"/>
        <xs:element ref="mods:partNumber" minOccurs="0" maxOccurs="1"/> 
      </xs:choice>
      <xs:attribute name="type" use="optional"/>
      <xs:attributeGroup ref="mods:authority-attributes-optional"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="title" type="xs:string">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:title">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
  </xs:element>
  <xs:element name="subTitle" type="xs:string">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:subTitle">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
  </xs:element>
  <xs:element name="partNumber" type="xs:string">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:partNumber">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
  </xs:element>
  <xs:element name="partName" type="xs:string">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:partName">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
  </xs:element>
  <xs:element name="languageTerm">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:languageTerm">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base="xs:string">
          <xs:attribute name="type" use="required" type="xs:string"/>
          <xs:attributeGroup ref="mods:authority-attributes-required"/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="identifier">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:identifier">
            <sch:extends rule="blank-element"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType mixed="true">
      <xs:annotation>
        <xs:appinfo>
          <sch:pattern>
            <sch:rule context="mods:identifier[@type='filename']">
              <sch:extends rule="trailing-punct"/>
            </sch:rule>
          </sch:pattern>
        </xs:appinfo>
      </xs:annotation>
      <xs:attribute name="type" use="required" type="xs:string"/>
      <xs:attribute name="invalid" use="optional" type="xs:string"/>
    </xs:complexType>     
  </xs:element>
</xs:schema>
