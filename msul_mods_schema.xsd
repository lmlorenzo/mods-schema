<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:sch="http://purl.oclc.org/dsdl/schematron" elementFormDefault="qualified" targetNamespace="http://www.loc.gov/mods/v3" xmlns:mods="http://www.loc.gov/mods/v3" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:cdl="http://www.cdlib.org/inside/diglib/copyrightMD">
  <xs:import namespace="http://www.w3.org/1999/xlink" schemaLocation="https://www.w3.org/XML/2008/06/xlink.xsd"/>
  <xs:import namespace="http://www.cdlib.org/inside/diglib/copyrightMD" schemaLocation="http://www.cdlib.org/groups/rmg/docs/copyrightMD.xsd"/>
  <xs:annotation>
    <xs:appinfo>
      <sch:title>MSUL MODS Schema/Schematron Validation</sch:title>
      <sch:ns prefix="mods" uri="http://www.loc.gov/mods/v3"/>
    </xs:appinfo>
  </xs:annotation>  
  <xs:element name="mods">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:mods">          
            <sch:assert test="count(mods:name[@usage='primary'])=1 or count(mods:name[@usage='primary'])=0">Record may only contain a maximum of one mods:name with @usage='primary'.</sch:assert>
            <sch:assert test="mods:subject[@authority='fast']">Record must have at least one FAST subject.</sch:assert>
            <sch:assert test="mods:originInfo/mods:dateOther[@type='year']">Record must have a mods:dateOther[@type='year'] element.</sch:assert>
            <sch:assert test="mods:genre[@authority='dct']">Record must have a DCTerms genre.</sch:assert>
            <sch:assert test="mods:genre[@authority='aat']">Record must have an AAT genre.</sch:assert>            
            <sch:assert test="mods:relatedItem[@type='host']">Record must contain a mods:relatedItem element with type attribute of 'host'.</sch:assert>
            <sch:assert test="mods:identifier[@type='filename']">Record must contain a mods:identifier element with type attribute of 'filename'.</sch:assert>
            <sch:assert test="mods:accessCondition[@type='use and reproduction'] or mods:accessCondition[@type='rights holder']">Record must have either a mods:accessCondition element with type attribute of 'use and reproduction' (for non-TIC resources) or with type attribute 'rights holder' (TIC resources).</sch:assert>
            <sch:assert test="mods:accessCondition[@type='dpla']">Record must have a mods:accessCondition element with type attribute of 'dpla'.</sch:assert>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType>
      <xs:choice maxOccurs="unbounded">
        <xs:element ref="mods:titleInfo" minOccurs="1" maxOccurs="unbounded"/>
        <xs:element ref="mods:name" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:typeOfResource" minOccurs="1" maxOccurs="1"/>
        <xs:element ref="mods:genre" minOccurs="2" maxOccurs="unbounded"/>
        <xs:element ref="mods:originInfo" minOccurs="1" maxOccurs="1"/>
        <xs:element ref="mods:language" minOccurs="1" maxOccurs="unbounded"/>
        <xs:element ref="mods:physicalDescription" minOccurs="1" maxOccurs="1"/>
        <xs:element ref="mods:abstract" minOccurs="0" maxOccurs="1"/>
        <xs:element ref="mods:note" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:subject" minOccurs="1" maxOccurs="unbounded"/>
        <xs:element ref="mods:classification" minOccurs="0"/>
        <xs:element ref="mods:location" minOccurs="0"/>
        <xs:element ref="mods:relatedItem" minOccurs="1"/>
        <xs:element ref="mods:identifier" minOccurs="1" maxOccurs="unbounded"/>
        <xs:element ref="mods:accessCondition" minOccurs="2" maxOccurs="2"/>
        <xs:element ref="mods:recordInfo" minOccurs="1" maxOccurs="1"/>
      </xs:choice>
      <xs:attribute name="version" type="xs:decimal"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="name">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="mods:namePart" maxOccurs="unbounded"/>
        <xs:element ref="mods:titleInfo" minOccurs="0" maxOccurs="1"/>
        <xs:element ref="mods:role" maxOccurs="unbounded"/>
      </xs:sequence>      
      <xs:attribute name="type" use="required" type="xs:string"/>
      <xs:attribute name="usage">
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:enumeration value="primary"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
      <xs:attributeGroup ref="mods:authority-attributes-optional"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="namePart">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule abstract="true" id="trailing-punct">
            <sch:assert role="warning" test="not(ends-with(.,'.')) and not(ends-with(.,',')) and not(ends-with(.,':')) and not(ends-with(.,' ')) and not(ends-with(.,'/')) or matches(.,' ([A-Z]\.){0,2}[A-Z]{1}\.$') or matches(.,' (Co|Inc)\.$') or matches(.,' ?(Mr|Mrs|Ms)\.$')">Check <sch:name/> for trailing punctuation.</sch:assert>
          </sch:rule>
        </sch:pattern>
        <sch:pattern>
          <sch:rule context="mods:namePart">
            <sch:extends rule="trailing-punct"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType mixed="true">
      <xs:attribute name="type" use="optional" type="xs:string"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="role">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="mods:roleTerm" maxOccurs="2"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="authority-attributes-required">
    <xs:attribute name="authority" use="required" type="xs:string"/>
    <xs:attribute name="authorityURI" use="required" type="xs:anyURI"/>
    <xs:attribute name="valueURI" use="required" type="xs:anyURI"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="authority-attributes-optional">
    <xs:attribute name="authority" use="optional" type="xs:string"/>
    <xs:attribute name="authorityURI" use="optional" type="xs:anyURI"/>
    <xs:attribute name="valueURI" use="optional" type="xs:anyURI"/>
  </xs:attributeGroup>
  <xs:element name="roleTerm">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:roleTerm">
            <sch:extends rule="trailing-punct"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType mixed="true">
      <xs:attribute name="type" use="required" type="xs:string"/>
      <xs:attributeGroup ref="mods:authority-attributes-required"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="typeOfResource" type="xs:string"/>
  <xs:element name="genre">
    <xs:complexType mixed="true">
      <xs:attributeGroup ref="mods:authority-attributes-required"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="originInfo">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule abstract="true" id="edtf-formatting">
            <sch:assert test="matches(.,'^([\dx]{4}|[\dx]{4}-[\dx]{2}|[\dx]{4}-[\dx]{2}-[\dx]{2}|unknown)[~?]?[/]?([\dx]{4}|[\dx]{4}-[\dx]{2}|[\dx]{4}-[\dx]{2}-[\dx]{2}|unknown|open)?[~?]?$')">Date in <sch:name/> is formatted incorrectly.</sch:assert>
          </sch:rule>
        </sch:pattern>
        <sch:pattern>
          <sch:rule context="mods:originInfo/mods:dateIssued">
            <sch:extends rule="edtf-formatting"/>
          </sch:rule>
          <sch:rule context="mods:originInfo/mods:dateCreated">
            <sch:extends rule="edtf-formatting"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType mixed="false">      
      <xs:choice maxOccurs="unbounded">
        <xs:element ref="mods:place"/>
        <xs:element ref="mods:publisher" minOccurs="0"/>
        <xs:element ref="mods:dateIssued"/>
        <xs:element ref="mods:dateCreated"/>
        <xs:element ref="mods:dateOther"/>
        <xs:element ref="mods:copyrightDate" minOccurs="0"/>
        <xs:element ref="mods:issuance" minOccurs="0"/>
        <xs:element ref="mods:frequency" minOccurs="0"/>
        <xs:element ref="mods:edition" minOccurs="0"/>
      </xs:choice>
      <xs:attribute name="eventType" use="optional"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="place">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="mods:placeTerm" maxOccurs="unbounded"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="placeTerm">
    <xs:complexType mixed="true">
      <xs:attribute name="type" use="required" type="xs:string"/>
      <xs:attributeGroup ref="mods:authority-attributes-optional"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="publisher">
    <xs:complexType mixed="true">
      <xs:simpleContent>
        <xs:extension base="xs:string">
          <xs:attributeGroup ref="mods:authority-attributes-optional"/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="dateIssued">
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base="xs:string">
          <xs:attribute name="encoding" use="required">
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="edtf"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="keyDate" use="required">
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="yes"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="dateCreated">
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base="xs:string">
          <xs:attribute name="encoding" use="required">
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="edtf"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="keyDate" use="required">
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="yes"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="copyrightDate">
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base="xs:string">
          <xs:attribute name="encoding" use="required">
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="edtf"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="dateOther">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:dateOther[@type='year']">
            <sch:assert test="matches(.,'^\d{4}$') or matches(.,'^\d{3}x$') or matches(.,'^\d{2}xx$') or matches(.,'^\dxxx$')">mods:dateOther[@type='year'] formatted incorrectly.</sch:assert>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base="xs:string">
          <xs:attribute name="encoding" use="required" type="xs:string"/>
          <xs:attribute name="type" use="required" type="xs:string"/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="issuance" type="xs:string"/>
  <xs:element name="frequency">
    <xs:complexType mixed="true">
      <xs:attributeGroup ref="mods:authority-attributes-optional"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="edition">
    <xs:complexType mixed="true">
      <xs:attribute name="supplied" use="optional"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="language">
    <xs:complexType>      
      <xs:sequence>
        <xs:element ref="mods:languageTerm" maxOccurs="unbounded"/>
      </xs:sequence>
      <xs:attribute name="objectPart" use="optional" type="xs:string"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="physicalDescription">
    <xs:complexType>
      <xs:choice maxOccurs="unbounded">
        <xs:element ref="mods:form" minOccurs="0"/>
        <xs:element ref="mods:internetMediaType" minOccurs="0"/>
        <xs:element ref="mods:extent" minOccurs="0"/>
        <xs:element ref="mods:digitalOrigin" minOccurs="0"/>
        <xs:element ref="mods:note" minOccurs="0"/>
      </xs:choice>
    </xs:complexType>
  </xs:element>
  <xs:element name="form">
    <xs:complexType mixed="true">
      <xs:attribute name="authority" use="required" type="xs:string"/>
      <xs:attribute name="authorityURI" use="optional" type="xs:anyURI"/>
      <xs:attribute name="valueURI" use="optional" type="xs:anyURI"/>
      <xs:attribute name="type" use="optional" type="xs:string"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="internetMediaType" type="xs:string"/>
  <xs:element name="extent" type="xs:string">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:physicalDescription">
            <sch:assert test="mods:extent" role="warning">Use of mods:physicalDescription/mods:extent is recommended.</sch:assert>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
  </xs:element>
  <xs:element name="digitalOrigin" type="xs:string"/>
  <xs:element name="abstract" type="xs:string"/>  
  <xs:element name="note">
    <xs:complexType mixed="true">
      <xs:attribute name="type" use="optional"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="subject">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:subject[@authority='lcsh' or @authority='fast']">
            <sch:assert test="@authorityURI">FAST and LCSH subjects must have an authorityURI attribute.</sch:assert>
          </sch:rule>
        </sch:pattern>
        <sch:pattern>
          <sch:rule context="mods:subject[@authority='fast'][not(mods:temporal)]">
            <sch:assert test="@valueURI">FAST subjects must have a valueURI attribute.</sch:assert>
          </sch:rule>
        </sch:pattern>
        <sch:pattern>
          <sch:rule context="mods:subject[@authority='fast'][not(mods:temporal)]">
            <sch:assert test="matches(@valueURI,'http://id.worldcat.org/fast/[0-9]{1,}$')">mods:subject[@authority='fast'] valueURI attribute formatted incorrectly.</sch:assert>
          </sch:rule>
          <sch:rule context="mods:subject[@authority='lcsh' and @valueURI][not(mods:temporal)]">
            <sch:assert test="matches(@valueURI,'http://id.loc.gov/authorities/subjects/sh[0-9]{7,}$') or matches(@valueURI,'http://id.loc.gov/authorities/names/n[a-z]?[0-9]{7,}$')">mods:subject[@authority='lcsh'] valueURI attribute formatted incorrectly.</sch:assert>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType>
      <xs:choice maxOccurs="unbounded">
        <xs:element ref="mods:topic" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:geographic" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:temporal" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:hierarchicalGeographic" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:titleInfo" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:geographicCode" minOccurs="0" maxOccurs="1"/>
        <xs:element ref="mods:cartographics" minOccurs="0" maxOccurs="1"/>
        <xs:element name="genre" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element name="name" minOccurs="0" maxOccurs="unbounded">
          <xs:complexType>
            <xs:sequence>
              <xs:element ref="mods:namePart" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="type" use="required" type="xs:string"/>
          </xs:complexType>
        </xs:element>
      </xs:choice>
      <xs:attribute name="authority" type="xs:string">
        <xs:annotation>
          <xs:appinfo>
            <sch:pattern>
              <sch:rule context="mods:subject[not(mods:cartographics)]">
                <sch:assert test="@authority" role="warn">Use of @authority attribute on mods:subject is highly recommended.</sch:assert>
              </sch:rule>
            </sch:pattern>
          </xs:appinfo>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="authorityURI" type="xs:anyURI"/>
      <xs:attribute name="valueURI" type="xs:anyURI"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="topic" type="xs:string"/>
  <xs:element name="geographic" type="xs:string"/>
  <xs:element name="temporal" type="xs:string"/>
  <xs:element name="geographicCode" type="xs:string"/>
  <xs:element name="cartographics">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="mods:coordinates" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:scale" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:projection" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="coordinates" type="xs:string"/>
  <xs:element name="scale" type="xs:string"/>
  <xs:element name="projection" type="xs:string"/>
  <xs:element name="hierarchicalGeographic">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="mods:continent" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:country" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:region" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:state" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:territory" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:county" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:city" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:citySection" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:island" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:area" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="mods:extraterrestrialArea" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="continent" type="xs:string"/>
  <xs:element name="country" type="xs:string"/>
  <xs:element name="region" type="xs:string"/>
  <xs:element name="state" type="xs:string"/>
  <xs:element name="territory" type="xs:string"/>
  <xs:element name="county" type="xs:string"/>
  <xs:element name="city" type="xs:string"/>
  <xs:element name="citySection" type="xs:string"/>
  <xs:element name="island" type="xs:string"/>
  <xs:element name="area" type="xs:string"/>
  <xs:element name="extraterrestrialArea" type="xs:string"/>
  <xs:element name="classification">
    <xs:complexType mixed="true">
      <xs:attribute name="authority" type="xs:string"/>
      <xs:attribute name="authorityURI" type="xs:anyURI"/>
      <xs:attribute name="valueURI" type="xs:anyURI"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="location">
    <xs:complexType>
      <xs:choice maxOccurs="unbounded">
        <xs:element ref="mods:physicalLocation"/>
        <xs:element ref="mods:url"/>
      </xs:choice>
    </xs:complexType>
  </xs:element>
  <xs:element name="url">
    <xs:complexType mixed="true">
      <xs:annotation>
        <xs:appinfo>
          <sch:pattern>
            <sch:rule context="mods:location/mods:url">
              <sch:assert test="@access or @usage or @note">mods:location/mods:url requires either a @usage, @access, or @note attribute.</sch:assert>
            </sch:rule>
          </sch:pattern>
        </xs:appinfo>
      </xs:annotation>
      <xs:simpleContent>
        <xs:extension base="xs:anyURI">
          <xs:attribute name="usage" use="optional">
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="primary"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="access" use="optional">
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="preview"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="note" use="optional"/>
        </xs:extension>
      </xs:simpleContent>     
    </xs:complexType>
  </xs:element>
  <xs:element name="physicalLocation">
    <xs:complexType mixed="true">
      <xs:attributeGroup ref="mods:authority-attributes-optional"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="relatedItem">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:relatedItem[@type='host']">
            <sch:assert test="mods:identifier[@type='oai_set']">mods:relatedItem[@type='host'] must have an oai_set identifier.</sch:assert>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType>
      <xs:choice maxOccurs="unbounded">
        <xs:element ref="mods:titleInfo" minOccurs="0"/>
        <xs:element ref="mods:location" minOccurs="0"/>
        <xs:element ref="mods:part" minOccurs="0"/>
        <xs:element ref="mods:identifier" minOccurs="0" maxOccurs="unbounded"/>
      </xs:choice>
      <xs:attribute name="type" use="required" type="xs:string"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="part">
    <xs:complexType>
      <xs:choice maxOccurs="unbounded">
        <xs:element ref="mods:detail" minOccurs="0"/>
      </xs:choice>
      <xs:attribute name="type" type="xs:string"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="detail">
    <xs:complexType>
      <xs:choice maxOccurs="unbounded">
        <xs:element ref="mods:number" minOccurs="0"/>
        <xs:element ref="mods:caption" minOccurs="0"/>
        <xs:element ref="mods:title" minOccurs="0"/>
      </xs:choice>
      <xs:attribute name="type" type="xs:string"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="number" type="xs:string"/>  
  <xs:element name="caption" type="xs:string"/>   
  <xs:element name="accessCondition">
    <xs:complexType mixed="true">
      <xs:sequence minOccurs="0">
        <xs:element ref="cdl:copyright" minOccurs="0"/>
        <!-- CDL's schema (imported) validates the cdl:copyright element -->
      </xs:sequence>
      <xs:attribute name="type" use="required"/>
      <xs:attribute ref="xlink:href" use="optional"/>
      <!-- xlink schema (imported) validates the xlink:href element -->
    </xs:complexType>
  </xs:element>  
  <xs:element name="recordInfo">
    <xs:complexType>
      <xs:choice maxOccurs="unbounded">
        <xs:element ref="mods:descriptionStandard" minOccurs="0"/>
        <xs:element ref="mods:recordContentSource" minOccurs="0" maxOccurs="2"/>
        <xs:element ref="mods:recordCreationDate" maxOccurs="1"/>
        <xs:element ref="mods:recordChangeDate" maxOccurs="1"/>
        <xs:element ref="mods:recordIdentifier" minOccurs="0" maxOccurs="1"/>
        <xs:element ref="mods:recordOrigin" maxOccurs="1"/>
        <xs:element ref="mods:languageOfCataloging"/>
      </xs:choice>
    </xs:complexType>
  </xs:element>
  <xs:element name="descriptionStandard">
    <xs:complexType mixed="true">
      <xs:attributeGroup ref="mods:authority-attributes-optional"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="recordContentSource">
    <xs:complexType mixed="true">
      <xs:attributeGroup ref="mods:authority-attributes-required"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="recordCreationDate">
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base="xs:date">
          <xs:attribute name="encoding" use="required" type="xs:string"/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="recordChangeDate">
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base="xs:date">
          <xs:attribute name="encoding" use="required" type="xs:string"/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="recordIdentifier">
    <xs:complexType mixed="true">
      <xs:attribute name="source" type="xs:string"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="recordOrigin" type="xs:string"/>
  <xs:element name="languageOfCataloging">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="mods:languageTerm"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="titleInfo">
    <xs:annotation>
      <xs:appinfo>
        <sch:pattern>
          <sch:rule context="mods:titleInfo/mods:title">
            <sch:extends rule="trailing-punct"/>
          </sch:rule>
        </sch:pattern>
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType>
      <xs:choice maxOccurs="unbounded">
        <xs:element ref="mods:title" minOccurs="1" maxOccurs="1"/>
        <xs:element ref="mods:subTitle" minOccurs="0" maxOccurs="1"/>
        <xs:element ref="mods:partName" minOccurs="0" maxOccurs="1"/>
        <xs:element ref="mods:partNumber" minOccurs="0" maxOccurs="1"/> 
      </xs:choice>
      <xs:attribute name="type" use="optional"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="title" type="xs:string"/>
  <xs:element name="subTitle" type="xs:string"/>
  <xs:element name="partNumber" type="xs:string"/>
  <xs:element name="partName" type="xs:string"/>
  <xs:element name="languageTerm">
    <xs:complexType>
      <xs:simpleContent>
        <xs:extension base="xs:string">
          <xs:attribute name="authority" use="required" type="xs:string"/>
          <xs:attribute name="authorityURI" type="xs:anyURI"/>
          <xs:attribute name="type" use="required" type="xs:string"/>
          <xs:attribute name="valueURI" type="xs:anyURI"/>
        </xs:extension>
      </xs:simpleContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="identifier">
    <xs:complexType mixed="true">
      <!--<xs:annotation>
        <xs:appinfo>
          <!-\- figure out how to account for variations in suffix between __mods.xml and _mods.xml, add alternate handling or exception for michilac -\->
          <sch:pattern>
            <sch:rule context="mods:identifier[@type='filename']">
              <sch:assert test=". = substring-before(tokenize(base-uri(),'/')[last()], 'mods.xml')">mods:identifier[@type='filename'] should match the filename (without any _mods.xml suffix).</sch:assert>
            </sch:rule>
          </sch:pattern>
          <sch:pattern>
            <sch:rule context="mods:identifier[@type='filename']">
              <sch:extends rule="trailing-punct"/>
            </sch:rule>
          </sch:pattern>
        </xs:appinfo>
      </xs:annotation>-->
      <xs:attribute name="type" use="required" type="xs:string"/>
      <xs:attribute name="invalid" use="optional" type="xs:string"/>
    </xs:complexType>     
  </xs:element>
</xs:schema>
